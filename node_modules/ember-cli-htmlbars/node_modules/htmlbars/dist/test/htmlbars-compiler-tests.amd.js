define("htmlbars-compiler-tests/fragment-test",
  ["../htmlbars-compiler/fragment-opcode-compiler","../htmlbars-compiler/fragment-javascript-compiler","../htmlbars-compiler/hydration-opcode-compiler","../htmlbars-compiler/hydration-javascript-compiler","../morph","../htmlbars-syntax/parser","../htmlbars-runtime/hooks","../htmlbars-test-helpers"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__) {
    "use strict";
    var FragmentOpcodeCompiler = __dependency1__["default"];
    var FragmentJavaScriptCompiler = __dependency2__["default"];
    var HydrationOpcodeCompiler = __dependency3__["default"];
    var HydrationJavaScriptCompiler = __dependency4__["default"];
    var DOMHelper = __dependency5__.DOMHelper;
    var preprocess = __dependency6__.preprocess;
    var get = __dependency7__.get;
    var equalHTML = __dependency8__.equalHTML;

    var xhtmlNamespace = "http://www.w3.org/1999/xhtml",
        svgNamespace = "http://www.w3.org/2000/svg";

    function fragmentFor(ast) {
      /* jshint evil: true */
      var fragmentOpcodeCompiler = new FragmentOpcodeCompiler(),
          fragmentCompiler = new FragmentJavaScriptCompiler();

      var opcodes = fragmentOpcodeCompiler.compile(ast);
      var program = fragmentCompiler.compile(opcodes);

      var fn = new Function("dom", 'return ' + program)();

      return fn(new DOMHelper());
    }

    function hydratorFor(ast) {
      /* jshint evil: true */
      var hydrate = new HydrationOpcodeCompiler();
      var opcodes = hydrate.compile(ast);
      var hydrate2 = new HydrationJavaScriptCompiler();
      var program = hydrate2.compile(opcodes, []);

      var hookVars = [];
      for (var hook in hydrate2.hooks) {
        hookVars.push(hook + ' = hooks.' + hook);
      }
      program =  'var ' + hookVars.join(', ') + ';\n' + program;
      return new Function("fragment", "context", "dom", "hooks", "env", "contextualElement", program);
    }

    QUnit.module('fragment');

    test('compiles a fragment', function () {
      var ast = preprocess("<div>{{foo}} bar {{baz}}</div>");
      var fragment = fragmentFor(ast);

      equalHTML(fragment, "<div> bar </div>");
    });

    test('compiles an svg fragment', function () {
      var ast = preprocess("<div><svg><circle/><foreignObject><span></span></foreignObject></svg></div>");
      var fragment = fragmentFor(ast);

      equal( fragment.childNodes[0].namespaceURI, svgNamespace,
             'svg has the right namespace' );
      equal( fragment.childNodes[0].childNodes[0].namespaceURI, svgNamespace,
             'circle has the right namespace' );
      equal( fragment.childNodes[0].childNodes[1].namespaceURI, svgNamespace,
             'foreignObject has the right namespace' );
      equal( fragment.childNodes[0].childNodes[1].childNodes[0].namespaceURI, xhtmlNamespace,
             'span has the right namespace' );
    });

    test('compiles an svg element with classes', function () {
      var ast = preprocess('<svg class="red right hand"></svg>');
      var fragment = fragmentFor(ast);

      equal(fragment.getAttribute('class'), 'red right hand');
    });

    test('converts entities to their char/string equivalent', function () {
      var ast = preprocess("<div title=\"&quot;Foo &amp; Bar&quot;\">lol &lt; &#60;&#x3c; &#x3C; &LT; &NotGreaterFullEqual; &Borksnorlax;</div>");
      var fragment = fragmentFor(ast);

      equal(fragment.getAttribute('title'), '"Foo & Bar"');
      equal(fragment.textContent, "lol < << < < ≧̸ &Borksnorlax;");
    });

    test('hydrates a fragment with morph mustaches', function () {
      var ast = preprocess("<div>{{foo \"bar\" 3 blah true bar=baz ack=\"syn\"}} bar {{baz}}</div>");
      var fragment = fragmentFor(ast).cloneNode(true);
      var hydrate = hydratorFor(ast);

      var contentResolves = [];
      var context = { blah: "BLAH", baz: "BAZ" };
      var env = {
        dom: new DOMHelper(),
        hooks: {
          get: get,
          content: function(morph, path, context, params, hash, options) {
            contentResolves.push({
              morph: morph,
              context: context,
              path: path,
              params: params,
              hash: hash,
              options: options
            });
          }
        }
      };

      hydrate(fragment, context, env.dom, env.hooks, env);

      equal(contentResolves.length, 2);

      var foo = contentResolves[0];
      equal(foo.morph.escaped, true);
      equal(foo.morph.parent(), fragment);
      equal(foo.context, context);
      equal(foo.path, 'foo');
      deepEqual(foo.params, ["bar",3,"BLAH", true]);
      deepEqual(foo.hash, {ack:"syn",bar:"BAZ"});

      var baz = contentResolves[1];
      equal(baz.morph.escaped, true);
      equal(baz.morph.parent(), fragment);
      equal(baz.context, context);
      equal(baz.path, 'baz');
      equal(baz.params.length, 0);

      foo.morph.update('A');
      baz.morph.update('B');

      equalHTML(fragment, "<div>A bar B</div>");
    });

    test('test auto insertion of text nodes for needed edges a fragment with morph mustaches', function () {
      var ast = preprocess("{{first}}<p>{{second}}</p>{{third}}");
      var dom = new DOMHelper();
      var fragment = dom.cloneNode(fragmentFor(ast), true);
      var hydrate = hydratorFor(ast);

      var morphs = [];
      var fakeMorphDOM = new DOMHelper();
      fakeMorphDOM.createMorphAt = function(){
        var morph = dom.createMorphAt.apply(this, arguments);
        morphs.push(morph);
        return morph;
      };

      var contentResolves = [];
      var context = {};
      var env = {
        dom: fakeMorphDOM,
        hooks: {
          get: get,
          content: function(morph, path, context, params, options) {
            contentResolves.push({
              morph: morph,
              context: context,
              path: path,
              params: params,
              options: options
            });
          }
        }
      };

      hydrate(fragment, context, env.dom, env.hooks, env, document.body);

      equal(morphs.length, 3);

      var t = morphs[0].start;
      equal(t.nodeType, 3);
      equal(t.textContent , '');
      equal(morphs[1].start, null);
      equal(morphs[1].end, null);

      equal(morphs[2].start, morphs[1].parent());
      equal(morphs[2].end.nodeType, 3);
      equal(morphs[2].end.textContent, '');

      morphs[0].update('A');
      morphs[1].update('B');
      morphs[2].update('C');

      equalHTML(fragment, "A<p>B</p>C");
    });
  });
define("htmlbars-compiler-tests/fragment-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/fragment-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/fragment-test.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/html-compiler-test",
  ["../htmlbars-compiler/compiler","../htmlbars-util/array-utils","../simple-html-tokenizer","../htmlbars-runtime/hooks","../htmlbars-runtime/helpers","../htmlbars-util/object-utils","../morph","../htmlbars-test-helpers"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__) {
    "use strict";
    var compile = __dependency1__.compile;
    var forEach = __dependency2__.forEach;
    var tokenize = __dependency3__.tokenize;
    var defaultHooks = __dependency4__["default"];
    var defaultHelpers = __dependency5__["default"];
    var merge = __dependency6__.merge;
    var DOMHelper = __dependency7__.DOMHelper;
    var normalizeInnerHTML = __dependency8__.normalizeInnerHTML;

    var xhtmlNamespace = "http://www.w3.org/1999/xhtml",
        svgNamespace   = "http://www.w3.org/2000/svg";

    var hooks, helpers, partials, env;

    function registerHelper(name, callback) {
      helpers[name] = callback;
    }

    function registerPartial(name, html) {
      partials[name] = compile(html);
    }

    function compilesTo(html, expected, context) {
      var template = compile(html);
      var fragment = template.render(context, env, document.body);
      equalTokens(fragment, expected === undefined ? html : expected);
      return fragment;
    }

    function equalTokens(fragment, html) {
      var div = document.createElement("div");
      div.appendChild(fragment.cloneNode(true));
      var fragTokens = tokenize(div.innerHTML);

      div.removeChild(div.childNodes[0]);
      div.innerHTML = html;
      var htmlTokens = tokenize(div.innerHTML);

      function normalizeTokens(token) {
        if (token.type === 'StartTag') {
          token.attributes = token.attributes.sort(function(a,b){
            if (a.name > b.name) {
              return 1;
            }
            if (a.name < b.name) {
              return -1;
            }
            return 0;
          });
        }
      }

      forEach(fragTokens, normalizeTokens);
      forEach(htmlTokens, normalizeTokens);

      deepEqual(fragTokens, htmlTokens);
    }

    function commonSetup() {
      hooks = merge({}, defaultHooks);
      helpers = merge({}, defaultHelpers);
      partials = {};

      env = {
        dom: new DOMHelper(),
        hooks: hooks,
        helpers: helpers,
        partials: partials
      };
    }

    QUnit.module("HTML-based compiler (output)", {
      setup: commonSetup
    });

    test("Simple content produces a document fragment", function() {
      var template = compile("content");
      var fragment = template.render({}, env);

      equalTokens(fragment, "content");
    });

    test("Simple elements are created", function() {
      var template = compile("<h1>hello!</h1><div>content</div>");
      var fragment = template.render({}, env);

      equalTokens(fragment, "<h1>hello!</h1><div>content</div>");
    });

    test("Simple elements can have attributes", function() {
      var template = compile("<div class='foo' id='bar'>content</div>");
      var fragment = template.render({}, env);

      equalTokens(fragment, '<div class="foo" id="bar">content</div>');
    });

    test("Simple elements can have an empty attribute", function() {
      var template = compile("<div class=''>content</div>");
      var fragment = template.render({}, env);

      equalTokens(fragment, '<div class="">content</div>');
    });

    test("Null quoted attribute value calls toString on the value", function() {
      var template = compile('<input disabled="{{isDisabled}}">');
      var fragment = template.render({isDisabled: null}, env);

      equalTokens(fragment, '<input disabled="null">');
    });

    test("Null unquoted attribute value removes that attribute", function() {

      var template = compile('<input disabled={{isDisabled}}>');
      var fragment = template.render({isDisabled: null}, env);

      equalTokens(fragment, '<input>');
    });

    test("unquoted attribute string is just that", function() {

      var template = compile('<input value=funstuff>');
      var fragment = template.render({}, env);

      equalTokens(fragment, '<input value="funstuff">');
    });

    test("unquoted attribute expression is string", function() {

      var template = compile('<input value={{funstuff}}>');
      var fragment = template.render({funstuff: "oh my"}, env);

      equalTokens(fragment, '<input value="oh my">');
    });

    test("unquoted attribute expression works when followed by another attribute", function() {

      var template = compile('<input value={{funstuff}} name="Alice">');
      var fragment = template.render({funstuff: "oh my"}, env);

      equalTokens(fragment, '<input value="oh my" name="Alice">');
    });

    test("Unquoted attribute value with multiple nodes throws an exception", function () {
      expect(4);

      QUnit.throws(function() { compile('<img class=foo{{bar}}>'); }, expectedError(1));
      QUnit.throws(function() { compile('<img class={{foo}}{{bar}}>'); }, expectedError(1));
      QUnit.throws(function() { compile('<img \nclass={{foo}}bar>'); }, expectedError(2));
      QUnit.throws(function() { compile('<div \nclass\n=\n{{foo}}&amp;bar ></div>'); }, expectedError(4));

      function expectedError(line) {
        return new Error("Unquoted attribute value must be a single string or mustache (line " + line + ")");
      }
    });

    test("Simple elements can have arbitrary attributes", function() {
      var template = compile("<div data-some-data='foo'>content</div>");
      var fragment = template.render({}, env);
      equalTokens(fragment, '<div data-some-data="foo">content</div>');
    });

    test("checked attribute and checked property are present after clone and hydrate", function() {
      var template = compile("<input checked=\"checked\">");
      var fragment = template.render({}, env);
      ok(fragment.checked, 'input is checked');
      equalTokens(fragment, "<input checked='checked'>");
    });

    test("SVG element can have capitalized attributes", function() {
      var template = compile("<svg viewBox=\"0 0 0 0\"></svg>");
      var fragment = template.render({}, env);
      equalTokens(fragment, '<svg viewBox=\"0 0 0 0\"></svg>');
    });

    function shouldBeVoid(tagName) {
      var html = "<" + tagName + " data-foo='bar'><p>hello</p>";
      var template = compile(html);
      var fragment = template.render({}, env);


      var div = document.createElement("div");
      div.appendChild(fragment.cloneNode(true));

      var tag = '<' + tagName + ' data-foo="bar">';
      var closing = '</' + tagName + '>';
      var extra = "<p>hello</p>";
      html = normalizeInnerHTML(div.innerHTML);

      QUnit.push((html === tag + extra) || (html === tag + closing + extra), html, tag + closing + extra, tagName + "should be a void element");
    }

    test("Void elements are self-closing", function() {
      var voidElements = "area base br col command embed hr img input keygen link meta param source track wbr";

      forEach(voidElements.split(" "), function(tagName) {
        shouldBeVoid(tagName);
      });
    });

    test("The compiler can handle nesting", function() {
      var html = '<div class="foo"><p><span id="bar" data-foo="bar">hi!</span></p></div> More content';
      var template = compile(html);
      var fragment = template.render({}, env);

      equalTokens(fragment, html);
    });

    test("The compiler can handle quotes", function() {
      compilesTo('<div>"This is a title," we\'re on a boat</div>');
    });

    test("The compiler can handle backslashes", function() {
      compilesTo('<div>This is a backslash: \\</div>');
    });

    test("The compiler can handle newlines", function() {
      compilesTo("<div>common\n\nbro</div>");
    });

    test("The compiler can handle comments", function() {
      compilesTo("<div>{{! Better not break! }}content</div>", '<div>content</div>', {});
    });

    test("The compiler can handle HTML comments", function() {
      compilesTo('<div><!-- Just passing through --></div>');
    });

    test("The compiler can handle HTML comments with mustaches in them", function() {
      compilesTo('<div><!-- {{foo}} --></div>', '<div><!-- {{foo}} --></div>', { foo: 'bar' });
    });

    test("The compiler can handle HTML comments with complex mustaches in them", function() {
      compilesTo('<div><!-- {{foo bar baz}} --></div>', '<div><!-- {{foo bar baz}} --></div>', { foo: 'bar' });
    });

    test("The compiler can handle HTML comments with multi-line mustaches in them", function() {
      compilesTo('<div><!-- {{#each foo as |bar|}}\n{{bar}}\n\n{{/each}} --></div>');
    });

    test('The compiler can handle comments with no parent element', function() {
      compilesTo('<!-- {{foo}} -->');
    });

    // TODO: Revisit partial syntax.
    // test("The compiler can handle partials in handlebars partial syntax", function() {
    //   registerPartial('partial_name', "<b>Partial Works!</b>");
    //   compilesTo('<div>{{>partial_name}} Plaintext content</div>', '<div><b>Partial Works!</b> Plaintext content</div>', {});
    // });

    test("The compiler can handle partials in helper partial syntax", function() {
      registerPartial('partial_name', "<b>Partial Works!</b>");
      compilesTo('<div>{{partial "partial_name"}} Plaintext content</div>', '<div><b>Partial Works!</b> Plaintext content</div>', {});
    });

    test("The compiler can handle simple handlebars", function() {
      compilesTo('<div>{{title}}</div>', '<div>hello</div>', { title: 'hello' });
    });

    test("The compiler can handle escaping HTML", function() {
      compilesTo('<div>{{title}}</div>', '<div>&lt;strong&gt;hello&lt;/strong&gt;</div>', { title: '<strong>hello</strong>' });
    });

    test("The compiler can handle unescaped HTML", function() {
      compilesTo('<div>{{{title}}}</div>', '<div><strong>hello</strong></div>', { title: '<strong>hello</strong>' });
    });

    test("The compiler can handle top-level unescaped HTML", function() {
      compilesTo('{{{html}}}', '<strong>hello</strong>', { html: '<strong>hello</strong>' });
    });

    test("The compiler can handle top-level unescaped tr", function() {
      var template = compile('{{{html}}}');
      var context = { html: '<tr><td>Yo</td></tr>' };
      var fragment = template.render(context, env, document.createElement('table'));

      equal(
        fragment.childNodes[1].tagName, 'TR',
        "root tr is present" );
    });

    test("The compiler can handle top-level unescaped td inside tr contextualElement", function() {
      var template = compile('{{{html}}}');
      var context = { html: '<td>Yo</td>' };
      var fragment = template.render(context, env, document.createElement('tr'));

      equal(
        fragment.childNodes[1].tagName, 'TD',
        "root td is returned" );
    });

    test("The compiler can handle unescaped tr in top of content", function() {
      registerHelper('test', function(params, hash, options, env) {
        return options.template.render(this, env, options.morph.contextualElement);
      });

      var template = compile('{{#test}}{{{html}}}{{/test}}');
      var context = { html: '<tr><td>Yo</td></tr>' };
      var fragment = template.render(context, env, document.createElement('table'));

      equal(
        fragment.childNodes[2].tagName, 'TR',
        "root tr is present" );
    });

    test("The compiler can handle unescaped tr inside fragment table", function() {
      registerHelper('test', function(params, hash, options, env) {
        return options.template.render(this, env, options.morph.contextualElement);
      });

      var template = compile('<table>{{#test}}{{{html}}}{{/test}}</table>');
      var context = { html: '<tr><td>Yo</td></tr>' };
      var fragment = template.render(context, env, document.createElement('div'));

      equal(
        fragment.childNodes[1].tagName, 'TR',
        "root tr is present" );
    });

    test("The compiler can handle simple helpers", function() {
      registerHelper('testing', function(params) {
        return params[0];
      });

      compilesTo('<div>{{testing title}}</div>', '<div>hello</div>', { title: 'hello' });
    });

    test("The compiler can handle sexpr helpers", function() {
      registerHelper('testing', function(params) {
        return params[0] + "!";
      });

      compilesTo('<div>{{testing (testing "hello")}}</div>', '<div>hello!!</div>', {});
    });

    test("The compiler can handle multiple invocations of sexprs", function() {
      registerHelper('testing', function(params) {
        return "" + params[0] + params[1];
      });

      compilesTo('<div>{{testing (testing "hello" foo) (testing (testing bar "lol") baz)}}</div>', '<div>helloFOOBARlolBAZ</div>', { foo: "FOO", bar: "BAR", baz: "BAZ" });
    });

    test("The compiler passes along the hash arguments", function() {
      registerHelper('testing', function(params, hash) {
        return hash.first + '-' + hash.second;
      });

      compilesTo('<div>{{testing first="one" second="two"}}</div>', '<div>one-two</div>');
    });

    test("Simple data binding using text nodes", function() {
      var callback;

      hooks.content = function(morph, path, context) {
        callback = function() {
          morph.update(context[path]);
        };
        callback();
      };

      var object = { title: 'hello' };
      var fragment = compilesTo('<div>{{title}} world</div>', '<div>hello world</div>', object);

      object.title = 'goodbye';
      callback();

      equalTokens(fragment, '<div>goodbye world</div>');

      object.title = 'brown cow';
      callback();

      equalTokens(fragment, '<div>brown cow world</div>');
    });

    test("Simple data binding on fragments", function() {
      var callback;

      hooks.content = function(morph, path, context) {
        morph.escaped = false;
        callback = function() {
          morph.update(context[path]);
        };
        callback();
      };

      var object = { title: '<p>hello</p> to the' };
      var fragment = compilesTo('<div>{{title}} world</div>', '<div><p>hello</p> to the world</div>', object);

      object.title = '<p>goodbye</p> to the';
      callback();

      equalTokens(fragment, '<div><p>goodbye</p> to the world</div>');

      object.title = '<p>brown cow</p> to the';
      callback();

      equalTokens(fragment, '<div><p>brown cow</p> to the world</div>');
    });

    test("morph receives escaping information", function() {
      expect(3);

      hooks.content = function(morph, path) {
        if (path === 'escaped') {
          equal(morph.escaped, true);
        } else if (path === 'unescaped') {
          equal(morph.escaped, false);
        }

        morph.update(path);
      };

      // so we NEED a reference to div. because it's passed in twice.
      // not divs childNodes.
      // the parent we need to save is fragment.childNodes
      compilesTo('<div>{{escaped}}-{{{unescaped}}}</div>', '<div>escaped-unescaped</div>');
    });

    test("Morphs are escaped correctly", function() {
      expect(10);

      registerHelper('testing-unescaped', function(params, hash, options) {
        equal(options.morph.escaped, false);

        return params[0];
      });

      registerHelper('testing-escaped', function(params, hash, options, env) {
        equal(options.morph.escaped, true);

        if (options.template) {
          return options.template.render({}, env, options.morph.contextualElement);
        }

        return params[0];
      });

      compilesTo('<div>{{{testing-unescaped}}}-{{{testing-unescaped "a"}}}</div>', '<div>-a</div>');
      compilesTo('<div>{{testing-escaped}}-{{testing-escaped "b"}}</div>', '<div>-b</div>');
      compilesTo('<div>{{#testing-escaped}}c{{/testing-escaped}}</div>', '<div>c</div>');
      compilesTo('<div><testing-escaped>c</testing-escaped></div>', '<div>c</div>');
    });

    test("Attributes can use computed values", function() {
      compilesTo('<a href="{{url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html' });
    });

    test("Mountain range of nesting", function() {
      var context = { foo: "FOO", bar: "BAR", baz: "BAZ", boo: "BOO", brew: "BREW", bat: "BAT", flute: "FLUTE", argh: "ARGH" };
      compilesTo('{{foo}}<span></span>', 'FOO<span></span>', context);
      compilesTo('<span></span>{{foo}}', '<span></span>FOO', context);
      compilesTo('<span>{{foo}}</span>{{foo}}', '<span>FOO</span>FOO', context);
      compilesTo('{{foo}}<span>{{foo}}</span>{{foo}}', 'FOO<span>FOO</span>FOO', context);
      compilesTo('{{foo}}<span></span>{{foo}}', 'FOO<span></span>FOO', context);
      compilesTo('{{foo}}<span></span>{{bar}}<span><span><span>{{baz}}</span></span></span>',
                 'FOO<span></span>BAR<span><span><span>BAZ</span></span></span>', context);
      compilesTo('{{foo}}<span></span>{{bar}}<span>{{argh}}<span><span>{{baz}}</span></span></span>',
                 'FOO<span></span>BAR<span>ARGH<span><span>BAZ</span></span></span>', context);
      compilesTo('{{foo}}<span>{{bar}}<a>{{baz}}<em>{{boo}}{{brew}}</em>{{bat}}</a></span><span><span>{{flute}}</span></span>{{argh}}',
                 'FOO<span>BAR<a>BAZ<em>BOOBREW</em>BAT</a></span><span><span>FLUTE</span></span>ARGH', context);
    });

    // test("Attributes can use computed paths", function() {
    //   compilesTo('<a href="{{post.url}}">linky</a>', '<a href="linky.html">linky</a>', { post: { url: 'linky.html' }});
    // });

    /*

    test("It is possible to use RESOLVE_IN_ATTR for data binding", function() {
      var callback;

      registerHelper('RESOLVE_IN_ATTR', function(parts, options) {
        return boundValue(function(c) {
          callback = c;
          return this[parts[0]];
        }, this);
      });

      var object = { url: 'linky.html' };
      var fragment = compilesTo('<a href="{{url}}">linky</a>', '<a href="linky.html">linky</a>', object);

      object.url = 'clippy.html';
      callback();

      equalTokens(fragment, '<a href="clippy.html">linky</a>');

      object.url = 'zippy.html';
      callback();

      equalTokens(fragment, '<a href="zippy.html">linky</a>');
    });
    */

    test("Attributes can be populated with helpers that generate a string", function() {
      registerHelper('testing', function(params) {
        return params[0];
      });

      compilesTo('<a href="{{testing url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html'});
    });
    /*
    test("A helper can return a stream for the attribute", function() {
      registerHelper('testing', function(path, options) {
        return streamValue(this[path]);
      });

      compilesTo('<a href="{{testing url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html'});
    });
    */
    test("Attribute helpers take a hash", function() {
      registerHelper('testing', function(params, hash) {
        return hash.path;
      });

      compilesTo('<a href="{{testing path=url}}">linky</a>', '<a href="linky.html">linky</a>', { url: 'linky.html' });
    });
    /*
    test("Attribute helpers can use the hash for data binding", function() {
      var callback;

      registerHelper('testing', function(path, hash, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path] ? hash.truthy : hash.falsy;
        }, this);
      });

      var object = { on: true };
      var fragment = compilesTo('<div class="{{testing on truthy="yeah" falsy="nope"}}">hi</div>', '<div class="yeah">hi</div>', object);

      object.on = false;
      callback();
      equalTokens(fragment, '<div class="nope">hi</div>');
    });
    */
    test("Attributes containing multiple helpers are treated like a block", function() {
      registerHelper('testing', function(params) {
        return params[0];
      });

      compilesTo('<a href="http://{{foo}}/{{testing bar}}/{{testing "baz"}}">linky</a>', '<a href="http://foo.com/bar/baz">linky</a>', { foo: 'foo.com', bar: 'bar' });
    });

    test("Attributes containing a helper are treated like a block", function() {
      expect(2);

      registerHelper('testing', function(params) {
        deepEqual(params, [123]);
        return "example.com";
      });

      compilesTo('<a href="http://{{testing 123}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', { person: { url: 'example.com' } });
    });
    /*
    test("It is possible to trigger a re-render of an attribute from a child resolution", function() {
      var callback;

      registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path];
        }, this);
      });

      var context = { url: "example.com" };
      var fragment = compilesTo('<a href="http://{{url}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', context);

      context.url = "www.example.com";
      callback();

      equalTokens(fragment, '<a href="http://www.example.com/index.html">linky</a>');
    });

    test("A child resolution can pass contextual information to the parent", function() {
      var callback;

      registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callback = c;
          return this[path];
        }, this);
      });

      var context = { url: "example.com" };
      var fragment = compilesTo('<a href="http://{{url}}/index.html">linky</a>', '<a href="http://example.com/index.html">linky</a>', context);

      context.url = "www.example.com";
      callback();

      equalTokens(fragment, '<a href="http://www.example.com/index.html">linky</a>');
    });

    test("Attribute runs can contain helpers", function() {
      var callbacks = [];

      registerHelper('RESOLVE_IN_ATTR', function(path, options) {
        return boundValue(function(c) {
          callbacks.push(c);
          return this[path];
        }, this);
      });

      registerHelper('testing', function(path, options) {
        return boundValue(function(c) {
          callbacks.push(c);

          if (options.paramTypes[0] === 'id') {
            return this[path] + '.html';
          } else {
            return path;
          }
        }, this);
      });

      var context = { url: "example.com", path: 'index' };
      var fragment = compilesTo('<a href="http://{{url}}/{{testing path}}/{{testing "linky"}}">linky</a>', '<a href="http://example.com/index.html/linky">linky</a>', context);

      context.url = "www.example.com";
      context.path = "yep";
      forEach(callbacks, function(callback) { callback(); });

      equalTokens(fragment, '<a href="http://www.example.com/yep.html/linky">linky</a>');

      context.url = "nope.example.com";
      context.path = "nope";
      forEach(callbacks, function(callback) { callback(); });

      equalTokens(fragment, '<a href="http://nope.example.com/nope.html/linky">linky</a>');
    });
    */
    test("A simple block helper can return the default document fragment", function() {

      hooks.content = function(morph, path, context, params, hash, options, env) {
        morph.update(options.template.render(context, env));
      };

      compilesTo('{{#testing}}<div id="test">123</div>{{/testing}}', '<div id="test">123</div>');
    });

    test("A simple block helper can return text", function() {
      hooks.content = function(morph, path, context, params, hash, options, env) {
        morph.update(options.template.render(context, env));
      };

      compilesTo('{{#testing}}test{{else}}not shown{{/testing}}', 'test');
    });

    test("A block helper can have an else block", function() {
      hooks.content = function(morph, path, context, params, hash, options, env) {
        morph.update(options.inverse.render(context, env));
      };

      compilesTo('{{#testing}}Nope{{else}}<div id="test">123</div>{{/testing}}', '<div id="test">123</div>');
    });

    test("A block helper can pass a context to be used in the child", function() {
      var originalContent = hooks.content;
      hooks.content = function(morph, path, context, params, hash, options, env) {
        if (path === 'testing') {
          morph.update(options.template.render({ title: 'Rails is omakase' }, env));
        } else {
          originalContent.apply(this, arguments);
        }
      };

      compilesTo('{{#testing}}<div id="test">{{title}}</div>{{/testing}}', '<div id="test">Rails is omakase</div>');
    });

    test("Block helpers receive hash arguments", function() {
      hooks.content = function(morph, path, context, params, hash, options, env) {
        if (hash.truth) {
          options.hooks = this;
          morph.update(options.template.render(context, env));
        }
      };

      compilesTo('{{#testing truth=true}}<p>Yep!</p>{{/testing}}{{#testing truth=false}}<p>Nope!</p>{{/testing}}', '<p>Yep!</p>');
    });
    /*

    test("Data-bound block helpers", function() {
      var callback;

      registerHelper('testing', function(path, options) {
        var context = this, firstElement, lastElement;

        var frag = buildFrag();

        function buildFrag() {
          var frag;

          var value = context[path];

          if (value) {
            frag = options.template.render(context);
          } else {
            frag = document.createDocumentFragment();
          }

          if (!frag.firstChild) {
            firstElement = lastElement = document.createTextNode('');
            frag.appendChild(firstElement);
          } else {
            firstElement = frag.firstChild;
            lastElement = frag.lastChild;
          }

          return frag;
        }

        callback = function() {
          var range = document.createRange();
          range.setStartBefore(firstElement);
          range.setEndAfter(lastElement);

          var frag = buildFrag();

          range.deleteContents();
          range.insertNode(frag);
        };

        return frag;
      });

      var object = { shouldRender: false };
      var template = '<p>hi</p> content {{#testing shouldRender}}<p>Appears!</p>{{/testing}} more <em>content</em> here';
      var fragment = compilesTo(template, '<p>hi</p> content  more <em>content</em> here', object);

      object.shouldRender = true;
      callback();

      equalTokens(fragment, '<p>hi</p> content <p>Appears!</p> more <em>content</em> here');

      object.shouldRender = false;
      callback();

      equalTokens(fragment, '<p>hi</p> content  more <em>content</em> here');
    });
    */

    test("Node helpers can modify the node", function() {
      registerHelper('testing', function(params, hash, options) {
        options.element.setAttribute('zomg', 'zomg');
      });

      compilesTo('<div {{testing}}>Node helpers</div>', '<div zomg="zomg">Node helpers</div>');
    });

    test("Node helpers can modify the node after one node appended by top-level helper", function() {
      registerHelper('top-helper', function() {
        return document.createElement('span');
      });
      registerHelper('attr-helper', function(params, hash, options) {
        options.element.setAttribute('zomg', 'zomg');
      });

      compilesTo('<div {{attr-helper}}>Node helpers</div>{{top-helper}}', '<div zomg="zomg">Node helpers</div><span></span>');
    });

    test("Node helpers can modify the node after one node prepended by top-level helper", function() {
      registerHelper('top-helper', function() {
        return document.createElement('span');
      });
      registerHelper('attr-helper', function(params, hash, options) {
        options.element.setAttribute('zomg', 'zomg');
      });

      compilesTo('{{top-helper}}<div {{attr-helper}}>Node helpers</div>', '<span></span><div zomg="zomg">Node helpers</div>');
    });

    test("Node helpers can modify the node after many nodes returned from top-level helper", function() {
      registerHelper('top-helper', function() {
        var frag = document.createDocumentFragment();
        frag.appendChild(document.createElement('span'));
        frag.appendChild(document.createElement('span'));
        return frag;
      });
      registerHelper('attr-helper', function(params, hash, options) {
        options.element.setAttribute('zomg', 'zomg');
      });

      compilesTo(
        '{{top-helper}}<div {{attr-helper}}>Node helpers</div>',
        '<span></span><span></span><div zomg="zomg">Node helpers</div>' );
    });

    test("Node helpers can be used for attribute bindings", function() {
      var callback;

      registerHelper('testing', function(params, hash, options) {
        var path = hash.href,
            element = options.element;
        var context = this;

        callback = function() {
          var value = context[path];
          element.setAttribute('href', value);
        };

        callback();
      });

      var object = { url: 'linky.html' };
      var fragment = compilesTo('<a {{testing href="url"}}>linky</a>', '<a href="linky.html">linky</a>', object);

      object.url = 'zippy.html';
      callback();

      equalTokens(fragment, '<a href="zippy.html">linky</a>');
    });


    test('Components - Called as helpers', function () {
      registerHelper('x-append', function(params, hash, options, env) {
        var fragment = options.template.render(this, env, options.morph.contextualElement);
        fragment.appendChild(document.createTextNode(hash.text));
        return fragment;
      });
      var object = { bar: 'e', baz: 'c' };
      compilesTo('a<x-append text="d{{bar}}">b{{baz}}</x-append>f','abcdef', object);
    });

    test('Components - Unknown helpers fall back to elements', function () {
      var object = { size: 'med', foo: 'b' };
      compilesTo('<x-bar class="btn-{{size}}">a{{foo}}c</x-bar>','<x-bar class="btn-med">abc</x-bar>', object);
    });

    test('Components - Text-only attributes work', function () {
      var object = { foo: 'qux' };
      compilesTo('<x-bar id="test">{{foo}}</x-bar>','<x-bar id="test">qux</x-bar>', object);
    });

    test('Components - Empty components work', function () {
      compilesTo('<x-bar></x-bar>','<x-bar></x-bar>', {});
    });

    test('Components - Text-only dashed attributes work', function () {
      var object = { foo: 'qux' };
      compilesTo('<x-bar aria-label="foo" id="test">{{foo}}</x-bar>','<x-bar aria-label="foo" id="test">qux</x-bar>', object);
    });

    test('Repaired text nodes are ensured in the right place', function () {
      var object = { a: "A", b: "B", c: "C", d: "D" };
      compilesTo('{{a}} {{b}}', 'A B', object);
      compilesTo('<div>{{a}}{{b}}{{c}}wat{{d}}</div>', '<div>ABCwatD</div>', object);
      compilesTo('{{a}}{{b}}<img><img><img><img>', 'AB<img><img><img><img>', object);
    });

    test("Simple elements can have dashed attributes", function() {
      var template = compile("<div aria-label='foo'>content</div>");
      var fragment = template.render({}, env);

      equalTokens(fragment, '<div aria-label="foo">content</div>');
    });

    test("Block params", function() {
      registerHelper('a', function(params, hash, options, env) {
        var context = Object.create(this);
        var span = document.createElement('span');
        span.appendChild(options.template.render(context, env, document.body, ['W', 'X1']));
        return 'A(' + span.innerHTML + ')';
      });
      registerHelper('b', function(params, hash, options, env) {
        var context = Object.create(this);
        var span = document.createElement('span');
        span.appendChild(options.template.render(context, env, document.body, ['X2', 'Y']));
        return 'B(' + span.innerHTML + ')';
      });
      registerHelper('c', function(params, hash, options, env) {
        var context = Object.create(this);
        var span = document.createElement('span');
        span.appendChild(options.template.render(context, env, document.body, ['Z']));
        return 'C(' + span.innerHTML + ')';
        // return "C(" + options.template.render() + ")";
      });
      var t = '{{#a as |w x|}}{{w}},{{x}} {{#b as |x y|}}{{x}},{{y}}{{/b}} {{w}},{{x}} {{#c as |z|}}{{x}},{{z}}{{/c}}{{/a}}';
      compilesTo(t, 'A(W,X1 B(X2,Y) W,X1 C(X1,Z))', {});
    });

    test("Block params - Helper should know how many block params it was called with", function() {
      expect(4);

      registerHelper('without-block-params', function(params, hash, options) {
        ok(!('blockParams' in options), 'Helpers should not be passed a blockParams option if not called with block params.');
      });
      registerHelper('with-block-params', function(params, hash, options) {
        equal(options.blockParams, this.count, 'Helpers should receive the correct number of block params in options.blockParams.');
      });

      compile('{{#without-block-params}}{{/without-block-params}}').render({}, env, document.body);
      compile('{{#with-block-params as |x|}}{{/with-block-params}}').render({ count: 1 }, env, document.body);
      compile('{{#with-block-params as |x y|}}{{/with-block-params}}').render({ count: 2 }, env, document.body);
      compile('{{#with-block-params as |x y z|}}{{/with-block-params}}').render({ count: 3 }, env, document.body);
    });

    test('Block params in HTML syntax', function () {
      registerHelper('x-bar', function(params, hash, options, env) {
        var context = Object.create(this);
        var span = document.createElement('span');
        span.appendChild(options.template.render(context, env, document.body, ['Xerxes', 'York', 'Zed']));
        return 'BAR(' + span.innerHTML + ')';
      });
      compilesTo('<x-bar as |x y zee|>{{zee}},{{y}},{{x}}</x-bar>', 'BAR(Zed,York,Xerxes)', {});
    });

    test('Block params in HTML syntax - Throws exception if given zero parameters', function () {
      expect(2);

      QUnit.throws(function() {
        compile('<x-bar as ||>foo</x-bar>');
      }, /Cannot use zero block parameters: 'as \|\|'/);
      QUnit.throws(function() {
        compile('<x-bar as | |>foo</x-bar>');
      }, /Cannot use zero block parameters: 'as \| \|'/);
    });


    test('Block params in HTML syntax - Works with a single parameter', function () {
      registerHelper('x-bar', function(params, hash, options, env) {
        return options.template.render({}, env, document.body, ['Xerxes']);
      });
      compilesTo('<x-bar as |x|>{{x}}</x-bar>', 'Xerxes', {});
    });

    test('Block params in HTML syntax - Works with other attributes', function () {
      registerHelper('x-bar', function(params, hash) {
        deepEqual(hash, {firstName: 'Alice', lastName: 'Smith'});
      });
      compile('<x-bar firstName="Alice" lastName="Smith" as |x y|></x-bar>').render({}, env, document.body);
    });

    test('Block params in HTML syntax - Ignores whitespace', function () {
      expect(3);

      registerHelper('x-bar', function(params, hash, options) {
        return options.template.render({}, env, document.body, ['Xerxes', 'York']);
      });
      compilesTo('<x-bar as |x y|>{{x}},{{y}}</x-bar>', 'Xerxes,York', {});
      compilesTo('<x-bar as | x y|>{{x}},{{y}}</x-bar>', 'Xerxes,York', {});
      compilesTo('<x-bar as | x y |>{{x}},{{y}}</x-bar>', 'Xerxes,York', {});
    });

    test('Block params in HTML syntax - Helper should know how many block params it was called with', function () {
      expect(4);

      registerHelper('without-block-params', function(params, hash, options) {
        ok(!('blockParams' in options), 'Helpers should not be passed a blockParams option if not called with block params.');
      });
      registerHelper('with-block-params', function(params, hash, options) {
        equal(options.blockParams, this.count, 'Helpers should receive the correct number of block params in options.blockParams.');
      });

      compile('<without-block-params></without-block-params>').render({}, env, document.body);
      compile('<with-block-params as |x|></with-block-params>').render({ count: 1 }, env, document.body);
      compile('<with-block-params as |x y|></with-block-params>').render({ count: 2 }, env, document.body);
      compile('<with-block-params as |x y z|></with-block-params>').render({ count: 3 }, env, document.body);
    });

    test("Block params in HTML syntax - Throws an error on invalid block params syntax", function() {
      expect(3);

      QUnit.throws(function() {
        compile('<x-bar as |x y>{{x}},{{y}}</x-bar>');
      }, /Invalid block parameters syntax: 'as |x y'/);
      QUnit.throws(function() {
        compile('<x-bar as |x| y>{{x}},{{y}}</x-bar>');
      }, /Invalid block parameters syntax: 'as \|x\| y'/);
      QUnit.throws(function() {
        compile('<x-bar as |x| y|>{{x}},{{y}}</x-bar>');
      }, /Invalid block parameters syntax: 'as \|x\| y\|'/);
    });

    test("Block params in HTML syntax - Throws an error on invalid identifiers for params", function() {
      expect(3);

      QUnit.throws(function() {
        compile('<x-bar as |x foo.bar|></x-bar>');
      }, /Invalid identifier for block parameters: 'foo\.bar' in 'as \|x foo\.bar|'/);
      QUnit.throws(function() {
        compile('<x-bar as |x "foo"|></x-bar>');
      }, /Invalid identifier for block parameters: '"foo"' in 'as \|x "foo"|'/);
      QUnit.throws(function() {
        compile('<x-bar as |foo[bar]|></x-bar>');
      }, /Invalid identifier for block parameters: 'foo\[bar\]' in 'as \|foo\[bar\]\|'/);
    });

    QUnit.module("HTML-based compiler (invalid HTML errors)", {
      setup: commonSetup
    });

    test("A helpful error message is provided for mismatched start/end tags", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\nSomething\n\n</div>");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include comment lines", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{! some comment}}\n\n</div>");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include mustache only lines", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{someProp}}\n\n</div>");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include block lines", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{#some-comment}}\n{{/some-comment}}\n</div>");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include whitespace control mustaches", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{someProp~}}\n\n</div>{{some-comment}}");
      }, /Closing tag `div` \(on line 5\) did not match last open tag `p` \(on line 2\)\./);
    });

    test("error line numbers include multiple mustache lines", function() {
      QUnit.throws(function() {
        compile("<div>\n<p>\n{{some-comment}}</div>{{some-comment}}");
      }, /Closing tag `div` \(on line 3\) did not match last open tag `p` \(on line 2\)\./);
    });

    if (document.createElement('div').namespaceURI) {

    QUnit.module("HTML-based compiler (output, svg)", {
      setup: commonSetup
    });

    test("The compiler can handle namespaced elements", function() {
      var html = '<svg><path stroke="black" d="M 0 0 L 100 100"></path></svg>';
      var template = compile(html);
      var fragment = template.render({}, env);

      equal(fragment.namespaceURI, svgNamespace, "creates the svg element with a namespace");
      equalTokens(fragment, html);
    });

    test("The compiler sets namespaces on nested namespaced elements", function() {
      var html = '<svg><path stroke="black" d="M 0 0 L 100 100"></path></svg>';
      var template = compile(html);
      var fragment = template.render({}, env);

      equal( fragment.childNodes[0].namespaceURI, svgNamespace,
             "creates the path element with a namespace" );
      equalTokens(fragment, html);
    });

    test("The compiler sets a namespace on an HTML integration point", function() {
      var html = '<svg><foreignObject>Hi</foreignObject></svg>';
      var template = compile(html);
      var fragment = template.render({}, env);

      equal( fragment.namespaceURI, svgNamespace,
             "creates the path element with a namespace" );
      equal( fragment.childNodes[0].namespaceURI, svgNamespace,
             "creates the path element with a namespace" );
      equalTokens(fragment, html);
    });

    test("The compiler does not set a namespace on an element inside an HTML integration point", function() {
      var html = '<svg><foreignObject><div></div></foreignObject></svg>';
      var template = compile(html);
      var fragment = template.render({}, env);

      equal( fragment.childNodes[0].childNodes[0].namespaceURI, xhtmlNamespace,
             "creates the path element with a namespace" );
      equalTokens(fragment, html);
    });

    test("The compiler pops back to the correct namespace", function() {
      var html = '<svg></svg><svg></svg><div></div>';
      var template = compile(html);
      var fragment = template.render({}, env);

      equal( fragment.childNodes[0].namespaceURI, svgNamespace,
             "creates the path element with a namespace" );
      equal( fragment.childNodes[1].namespaceURI, svgNamespace,
             "creates the path element with a namespace" );
      equal( fragment.childNodes[2].namespaceURI, xhtmlNamespace,
             "creates the path element with a namespace" );
      equalTokens(fragment, html);
    });

    test("The compiler preserves capitalization of tags", function() {
      var html = '<svg><linearGradient id="gradient"></linearGradient></svg>';
      var template = compile(html);
      var fragment = template.render({}, env);

      equalTokens(fragment, html);
    });

    test("svg can live with hydration", function() {
      var template = compile('<svg></svg>{{name}}');

      var fragment = template.render({ name: 'Milly' }, env, document.body);
      equal(
        fragment.childNodes[0].namespaceURI, svgNamespace,
        "svg namespace inside a block is present" );
    });

    test("svg can take some hydration", function() {
      var template = compile('<div><svg>{{name}}</svg></div>');

      var fragment = template.render({ name: 'Milly' }, env);
      equal(
        fragment.childNodes[0].namespaceURI, svgNamespace,
        "svg namespace inside a block is present" );
      equalTokens( fragment, '<div><svg>Milly</svg></div>',
                 "html is valid" );
    });

    test("root svg can take some hydration", function() {
      var template = compile('<svg>{{name}}</svg>');
      var fragment = template.render({ name: 'Milly' }, env);
      equal(
        fragment.namespaceURI, svgNamespace,
        "svg namespace inside a block is present" );
      equalTokens( fragment, '<svg>Milly</svg>',
                 "html is valid" );
    });

    test("Block helper allows interior namespace", function() {
      var isTrue = true;
      hooks.content = function(morph, path, context, params, hash, options, env) {
        if (isTrue) {
          morph.update(options.template.render(context, env, morph.contextualElement));
        } else {
         morph.update(options.inverse.render(context, env, morph.contextualElement));
        }
      };
      var template = compile('{{#testing}}<svg></svg>{{else}}<div><svg></svg></div>{{/testing}}');

      var fragment = template.render({ isTrue: true }, env, document.body);
      equal(
        fragment.childNodes[1].namespaceURI, svgNamespace,
        "svg namespace inside a block is present" );

      isTrue = false;
      fragment = template.render({ isTrue: false }, env, document.body);
      equal(
        fragment.childNodes[1].namespaceURI, xhtmlNamespace,
        "inverse block path has a normal namespace");
      equal(
        fragment.childNodes[1].childNodes[0].namespaceURI, svgNamespace,
        "svg namespace inside an element inside a block is present" );
    });

    test("Block helper allows namespace to bleed through", function() {
      hooks.content = function(morph, path, context, params, hash, options, env) {
        morph.update(options.template.render(context, env, morph.contextualElement));
      };

      var template = compile('<div><svg>{{#testing}}<circle />{{/testing}}</svg></div>');

      var fragment = template.render({ isTrue: true }, env);
      equal( fragment.childNodes[0].namespaceURI, svgNamespace,
             "svg tag has an svg namespace" );
      equal( fragment.childNodes[0].childNodes[0].namespaceURI, svgNamespace,
             "circle tag inside block inside svg has an svg namespace" );
    });

    test("Block helper with root svg allows namespace to bleed through", function() {
      hooks.content = function(morph, path, context, params, hash, options, env) {
        morph.update(options.template.render(context, env, morph.contextualElement));
      };

      var template = compile('<svg>{{#testing}}<circle />{{/testing}}</svg>');

      var fragment = template.render({ isTrue: true }, env);
      equal( fragment.namespaceURI, svgNamespace,
             "svg tag has an svg namespace" );
      equal( fragment.childNodes[0].namespaceURI, svgNamespace,
             "circle tag inside block inside svg has an svg namespace" );
    });

    test("Block helper with root foreignObject allows namespace to bleed through", function() {
      hooks.content = function(morph, path, context, params, hash, options, env) {
        morph.update(options.template.render(context, env, morph.contextualElement));
      };

      var template = compile('<foreignObject>{{#testing}}<div></div>{{/testing}}</foreignObject>');

      var fragment = template.render({ isTrue: true }, env, document.createElementNS(svgNamespace, 'svg'));
      equal( fragment.namespaceURI, svgNamespace,
             "foreignObject tag has an svg namespace" );
      equal( fragment.childNodes[0].namespaceURI, xhtmlNamespace,
             "div inside morph and foreignObject has xhtml namespace" );
    });

    }
  });
define("htmlbars-compiler-tests/html-compiler-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/html-compiler-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/html-compiler-test.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/htmlbars-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/fragment-javascript-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/fragment-javascript-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/fragment-javascript-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/fragment-opcode-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/fragment-opcode-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/fragment-opcode-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/hydration-javascript-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/hydration-javascript-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/hydration-javascript-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/hydration-opcode-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/hydration-opcode-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/hydration-opcode-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/template-compiler.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/template-compiler.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/template-compiler.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/template-visitor.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/template-visitor.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/template-visitor.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/htmlbars-compiler/utils.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests/htmlbars-compiler');
    test('htmlbars-compiler-tests/htmlbars-compiler/utils.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/htmlbars-compiler/utils.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/hydration-opcode-compiler-test",
  ["../htmlbars-compiler/hydration-opcode-compiler","../htmlbars-syntax/parser"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var HydrationOpcodeCompiler = __dependency1__["default"];
    var preprocess = __dependency2__.preprocess;

    function opcodesFor(html, options) {
      var ast = preprocess(html, options),
          compiler1 = new HydrationOpcodeCompiler(options);
      compiler1.compile(ast);
      return compiler1.opcodes;
    }

    QUnit.module("HydrationOpcodeCompiler opcode generation");

    test("simple example", function() {
      var opcodes = opcodesFor("<div>{{foo}} bar {{baz}}</div>");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [ 0 ], -1, 0, true ] ],
        [ "createMorph", [ 1, [ 0 ], 0, -1, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForAmbiguous", [ 0 ] ],
        [ "pushLiteral", [ "baz" ] ],
        [ "printContentHookForAmbiguous", [ 1 ] ],
      ]);
    });

    test("simple block", function() {
      var opcodes = opcodesFor("<div>{{#foo}}{{/foo}}</div>");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [ 0 ], null, null, true ] ],
        [ "prepareObject", [ 0 ] ],
        [ "prepareArray", [ 0 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForBlockHelper", [ 0, 0, null, 0 ] ]
      ]);
    });

    test("simple block with block params", function() {
      var opcodes = opcodesFor("<div>{{#foo as |bar baz|}}{{/foo}}</div>");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [ 0 ], null, null, true ] ],
        [ "prepareObject", [ 0 ] ],
        [ "prepareArray", [ 0 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForBlockHelper", [ 0, 0, null, 2 ] ]
      ]);
    });

    test("element with a sole mustache child", function() {
      var opcodes = opcodesFor("<div>{{foo}}</div>");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [ 0 ], -1, -1, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForAmbiguous", [ 0 ] ],
      ]);
    });

    test("element with a mustache between two text nodes", function() {
      var opcodes = opcodesFor("<div> {{foo}} </div>");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [ 0 ], 0, 1, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForAmbiguous", [ 0 ] ],
      ]);
    });

    test("mustache two elements deep", function() {
      var opcodes = opcodesFor("<div><div>{{foo}}</div></div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [ 0, 0 ], -1, -1, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForAmbiguous", [ 0 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("two sibling elements with mustaches", function() {
      var opcodes = opcodesFor("<div>{{foo}}</div><div>{{bar}}</div>");
      deepEqual(opcodes, [
        [ "consumeParent", [ 0 ] ],
        [ "createMorph", [ 0, [ 0 ], -1, -1, true ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForAmbiguous", [ 0 ] ],
        [ "popParent", [] ],
        [ "consumeParent", [ 1 ] ],
        [ "createMorph", [ 1, [ 1 ], -1, -1, true ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "printContentHookForAmbiguous", [ 1 ] ],
        [ "popParent", [] ]
      ]);
    });

    test("mustaches at the root", function() {
      var opcodes = opcodesFor("{{foo}} {{bar}}");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [ ], 0, 1, true ] ],
        [ "createMorph", [ 1, [ ], 1, 2, true ] ],
        [ "repairClonedNode", [ [ 0, 2 ] ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForAmbiguous", [ 0 ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "printContentHookForAmbiguous", [ 1 ] ],
      ]);
    });

    test("back to back mustaches should have a text node inserted between them", function() {
      var opcodes = opcodesFor("<div>{{foo}}{{bar}}{{baz}}wat{{qux}}</div>");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [0], -1, 0, true ] ],
        [ "createMorph", [ 1, [0], 0, 1, true ] ],
        [ "createMorph", [ 2, [0], 1, 2, true ] ],
        [ "createMorph", [ 3, [0], 2, -1, true] ],
        [ "repairClonedNode", [ [ 0, 1 ], false ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForAmbiguous", [ 0 ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "printContentHookForAmbiguous", [ 1 ] ],
        [ "pushLiteral", [ "baz" ] ],
        [ "printContentHookForAmbiguous", [ 2 ] ],
        [ "pushLiteral", [ "qux" ] ],
        [ "printContentHookForAmbiguous", [ 3 ] ],
      ]);
    });

    test("helper usage", function() {
      var opcodes = opcodesFor("<div>{{foo 'bar' baz.bat true 3.14}}</div>");
      deepEqual(opcodes, [
        [ "createMorph", [ 0, [0], -1, -1, true ] ],
        [ "prepareObject", [ 0 ] ],
        [ "pushLiteral", [ 3.14 ] ],
        [ "pushLiteral", [ true ] ],
        [ "pushGetHook", [ "baz.bat" ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "prepareArray", [ 4 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "printContentHookForInlineHelper", [ 0 ] ]
      ]);
    });

    test("node mustache", function() {
      var opcodes = opcodesFor("<div {{foo}}></div>");
      deepEqual(opcodes, [
        [ "prepareObject", [ 0 ] ],
        [ "prepareArray", [ 0 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "shareElement", [ 0 ] ],
        [ "printElementHook", [ 0 ] ]
      ]);
    });

    test("node helper", function() {
      var opcodes = opcodesFor("<div {{foo 'bar'}}></div>");
      deepEqual(opcodes, [
        [ "prepareObject", [ 0 ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "prepareArray", [ 1 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "shareElement", [ 0 ] ],
        [ "printElementHook", [ 0 ] ]
      ]);
    });

    test("attribute mustache", function() {
      var opcodes = opcodesFor("<div class='before {{foo}} after'></div>");
      deepEqual(opcodes, [
        [ "pushLiteral", [ " after" ] ],
        [ "pushGetHook", [ "foo" ] ],
        [ "pushLiteral", [ "before " ] ],
        [ "prepareArray", [ 3 ] ],
        [ "pushConcatHook", [ ] ],
        [ "pushLiteral", [ "class" ] ],
        [ "shareElement", [ 0 ] ],
        [ "printAttributeHook", [ 0, true ] ]
      ]);
    });


    test("attribute helper", function() {
      var opcodes = opcodesFor("<div class='before {{foo 'bar'}} after'></div>");
      deepEqual(opcodes, [
        [ "pushLiteral", [ " after" ] ],
        [ "prepareObject", [ 0 ] ],
        [ "pushLiteral", [ "bar" ] ],
        [ "prepareArray", [ 1 ] ],
        [ "pushLiteral", [ "foo" ] ],
        [ "pushSexprHook", [ ] ],
        [ "pushLiteral", [ "before " ] ],
        [ "prepareArray", [ 3 ] ],
        [ "pushConcatHook", [ ] ],
        [ "pushLiteral", [ "class" ] ],
        [ "shareElement", [ 0 ] ],
        [ "printAttributeHook", [ 0, true ] ]
      ]);
    });
  });
define("htmlbars-compiler-tests/hydration-opcode-compiler-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/hydration-opcode-compiler-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/hydration-opcode-compiler-test.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/template-compiler-test",
  ["../htmlbars-compiler/template-compiler","../htmlbars-syntax/parser","../htmlbars-test-helpers","../htmlbars-runtime/hooks","../htmlbars-runtime/helpers","../htmlbars-util/object-utils","../morph"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__) {
    "use strict";
    var TemplateCompiler = __dependency1__["default"];
    var preprocess = __dependency2__.preprocess;
    var equalHTML = __dependency3__.equalHTML;
    var defaultHooks = __dependency4__["default"];
    var defaultHelpers = __dependency5__["default"];
    var merge = __dependency6__.merge;
    var DOMHelper = __dependency7__.DOMHelper;

    QUnit.module("TemplateCompiler");

    var dom, hooks, helpers;

    test("it works", function testFunction() {
      /* jshint evil: true */
      var ast = preprocess('<div>{{#if working}}Hello {{firstName}} {{lastName}}!{{/if}}</div>');
      var compiler = new TemplateCompiler();
      var program = compiler.compile(ast);
      var template = new Function("return " + program)();

      dom = new DOMHelper();
      hooks = merge({}, defaultHooks);
      helpers = merge({}, defaultHelpers);
      
      var env = {
        dom: dom,
        hooks: hooks,
        helpers: helpers 
      };

      env.helpers['if'] = function(params, hash, options) {
        if (params[0]) {
          return options.template.render(context, env, options.morph.contextualElement);
        }
      };

      var context = {
        working: true,
        firstName: 'Kris',
        lastName: 'Selden'
      };
      var frag = template.render(context, env, document.body);
      equalHTML(frag, '<div>Hello Kris Selden!</div>');
    });
  });
define("htmlbars-compiler-tests/template-compiler-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/template-compiler-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/template-compiler-test.js should pass jshint.'); 
    });
  });
define("htmlbars-compiler-tests/template-visitor-test",
  ["../htmlbars-syntax/parser","../htmlbars-compiler/template-visitor"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var preprocess = __dependency1__.preprocess;
    var TemplateVisitor = __dependency2__["default"];

    function actionsEqual(input, expectedActions) {
      var ast = preprocess(input);

      var templateVisitor = new TemplateVisitor();
      templateVisitor.visit(ast);
      var actualActions = templateVisitor.actions;

      // Remove the AST node reference from the actions to keep tests leaner
      for (var i = 0; i < actualActions.length; i++) {
        actualActions[i][1].shift();
      }

      deepEqual(actualActions, expectedActions);
    }

    QUnit.module("TemplateVisitor");

    test("empty", function() {
      var input = "";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['endProgram', [0]]
      ]);
    });

    test("basic", function() {
      var input = "foo{{bar}}<div></div>";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['text', [0, 3, false]],
        ['mustache', [1, 3]],
        ['openElement', [2, 3, false, 0, []]],
        ['closeElement', [2, 3, false]],
        ['endProgram', [0]]
      ]);
    });

    test("nested HTML", function() {
      var input = "<a></a><a><a><a></a></a></a>";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['openElement', [0, 2, false, 0, []]],
        ['closeElement', [0, 2, false]],
        ['openElement', [1, 2, false, 0, []]],
        ['openElement', [0, 1, false, 0, []]],
        ['openElement', [0, 1, false, 0, []]],
        ['closeElement', [0, 1, false]],
        ['closeElement', [0, 1, false]],
        ['closeElement', [1, 2, false]],
        ['endProgram', [0]]
      ]);
    });

    test("mustaches are counted correctly", function() {
      var input = "<a><a>{{foo}}</a><a {{foo}}><a>{{foo}}</a><a>{{foo}}</a></a></a>";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['openElement', [0, 1, true, 2, []]],
        ['openElement', [0, 2, false, 1, []]],
        ['mustache', [0, 1]],
        ['closeElement', [0, 2, false]],
        ['openElement', [1, 2, false, 3, []]],
        ['openElement', [0, 2, false, 1, []]],
        ['mustache', [0, 1]],
        ['closeElement', [0, 2, false]],
        ['openElement', [1, 2, false, 1, []]],
        ['mustache', [0, 1]],
        ['closeElement', [1, 2, false]],
        ['closeElement', [1, 2, false]],
        ['closeElement', [0, 1, true]],
        ['endProgram', [0]]
      ]);
    });

    test("empty block", function() {
      var input = "{{#a}}{{/a}}";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['endProgram', [1]],
        ['startProgram', [1, [0, 1]]],
        ['text', [0, 3, false]],
        ['block', [1, 3]],
        ['text', [2, 3, false]],
        ['endProgram', [0]]
      ]);
    });

    test("block with inverse", function() {
      var input = "{{#a}}b{{^}}{{/a}}";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['endProgram', [1]],
        ['startProgram', [0, []]],
        ['text', [0, 1, true]],
        ['endProgram', [1]],
        ['startProgram', [2, [0, 1]]],
        ['text', [0, 3, false]],
        ['block', [1, 3]],
        ['text', [2, 3, false]],
        ['endProgram', [0]]
      ]);
    });

    test("nested blocks", function() {
      var input = "{{#a}}{{#a}}<b></b>{{/a}}{{#a}}{{b}}{{/a}}{{/a}}{{#a}}b{{/a}}";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['text', [0, 1, true]],
        ['endProgram', [1]],
        ['startProgram', [0, [0, 1]]],
        ['text', [0, 3, false]],
        ['mustache', [1, 3]],
        ['text', [2, 3, false]],
        ['endProgram', [2]],
        ['startProgram', [0, []]],
        ['openElement', [0, 1, true, 0, []]],
        ['closeElement', [0, 1, true]],
        ['endProgram', [2]],
        ['startProgram', [2, [0, 1, 2]]],
        ['text', [0, 5, false]],
        ['block', [1, 5]],
        ['text', [2, 5, false]],
        ['block', [3, 5]],
        ['text', [4, 5, false]],
        ['endProgram', [1]],
        ['startProgram', [2, [0, 1, 2]]],
        ['text', [0, 5, false]],
        ['block', [1, 5]],
        ['text', [2, 5, false]],
        ['block', [3, 5]],
        ['text', [4, 5, false]],
        ['endProgram', [0]]
      ]);
    });

    test("component", function() {
      var input = "<x-foo>bar</x-foo>";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['text', [0, 1, true]],
        ['endProgram', [1]],
        ['startProgram', [1, [0, 1]]],
        ['text', [0, 3, false]],
        ['component', [1, 3]],
        ['text', [2, 3, false]],
        ['endProgram', [0]]
      ]);
    });

    test("comment", function() {
      var input = "<!-- some comment -->";
      actionsEqual(input, [
        ['startProgram', [0, []]],
        ['comment', [0, 1, true]],
        ['endProgram', [0]]
      ]);
    });
  });
define("htmlbars-compiler-tests/template-visitor-test.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-compiler-tests');
    test('htmlbars-compiler-tests/template-visitor-test.js should pass jshint', function() { 
      ok(true, 'htmlbars-compiler-tests/template-visitor-test.js should pass jshint.'); 
    });
  });
define("htmlbars-runtime",
  ["htmlbars-runtime/hooks","htmlbars-runtime/helpers","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var hooks = __dependency1__["default"];
    var helpers = __dependency2__["default"];

    __exports__.hooks = hooks;
    __exports__.helpers = helpers;
  });
define("htmlbars-runtime.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('htmlbars-runtime.js should pass jshint', function() { 
      ok(true, 'htmlbars-runtime.js should pass jshint.'); 
    });
  });
define("htmlbars-runtime/helpers",
  ["exports"],
  function(__exports__) {
    "use strict";
    function partial(params, hash, options, env) {
      var template = env.partials[params[0]];
      return template.render(this, env, options.morph.contextualElement);
    }

    __exports__.partial = partial;__exports__["default"] = {
      partial: partial
    };
  });
define("htmlbars-runtime/helpers.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-runtime');
    test('htmlbars-runtime/helpers.js should pass jshint', function() { 
      ok(true, 'htmlbars-runtime/helpers.js should pass jshint.'); 
    });
  });
define("htmlbars-runtime/hooks",
  ["exports"],
  function(__exports__) {
    "use strict";
    function content(morph, path, context, params, hash, options, env) {
      var value, helper = lookupHelper(context, path, env);
      if (helper) {
        value = helper.call(context, params, hash, options, env);
      } else {
        value = get(context, path);
      }
      morph.update(value);
    }

    __exports__.content = content;function element(domElement, helperName, context, params, hash, options, env) {
      var helper = lookupHelper(context, helperName, env);
      if (helper) {
        helper.call(context, params, hash, options, env);
      }
    }

    __exports__.element = element;function attribute(domElement, name, quoted, context, value) {
      if (value === null) {
        domElement.removeAttribute(name);
      } else {
        domElement.setAttribute(name, value);
      }
    }

    __exports__.attribute = attribute;function subexpr(helperName, context, params, hash, options, env) {
      var helper = lookupHelper(context, helperName, env);
      if (helper) {
        return helper.call(context, params, hash, options, env);
      } else {
        return get(context, helperName, options);
      }
    }

    __exports__.subexpr = subexpr;function get(context, path) {
      if (path === '') {
        return context;
      }

      var keys = path.split('.');
      var value = context;
      for (var i = 0; i < keys.length; i++) {
        if (value) {
          value = value[keys[i]];
        } else {
          break;
        }
      }
      return value;
    }

    __exports__.get = get;function set(context, name, value) {
      context[name] = value;
    }

    __exports__.set = set;function component(morph, tagName, context, hash, options, env) {
      var value, helper = lookupHelper(context, tagName, env);
      if (helper) {
        value = helper.call(context, null, hash, options, env);
      } else {
        value = componentFallback(morph, tagName, context, hash, options, env);
      }
      morph.update(value);
    }

    __exports__.component = component;function concat(params) {
      var value = "";
      for (var i = 0, l = params.length; i < l; i++) {
        value += params[i];
      }
      return value;
    }

    __exports__.concat = concat;function componentFallback(morph, tagName, context, hash, options, env) {
      var element = env.dom.createElement(tagName);
      for (var name in hash) {
        element.setAttribute(name, hash[name]);
      }
      element.appendChild(options.template.render(context, env, morph.contextualElement));
      return element;
    }

    function lookupHelper(context, helperName, env) {
      return env.helpers[helperName];
    }

    __exports__["default"] = {
      content: content,
      component: component,
      element: element,
      attribute: attribute,
      subexpr: subexpr,
      concat: concat,
      get: get,
      set: set
    };
  });
define("htmlbars-runtime/hooks.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - htmlbars-runtime');
    test('htmlbars-runtime/hooks.js should pass jshint', function() { 
      ok(true, 'htmlbars-runtime/hooks.js should pass jshint.'); 
    });
  });
define("htmlbars-test-helpers",
  ["exports"],
  function(__exports__) {
    "use strict";
    function equalInnerHTML(fragment, html) {
      var actualHTML = normalizeInnerHTML(fragment.innerHTML);
      QUnit.push(actualHTML === html, actualHTML, html);
    }

    __exports__.equalInnerHTML = equalInnerHTML;function equalHTML(node, html) {
      var fragment;
      if (!node.nodeType && node.length) {
        fragment = document.createDocumentFragment();
        while (node[0]) {
          fragment.appendChild(node[0]);
        }
      } else {
        fragment = node;
      }

      var div = document.createElement("div");
      div.appendChild(fragment.cloneNode(true));

      equalInnerHTML(div, html);
    }

    __exports__.equalHTML = equalHTML;// detect weird IE8 html strings
    var ie8InnerHTMLTestElement = document.createElement('div');
    ie8InnerHTMLTestElement.setAttribute('id', 'womp');
    var ie8InnerHTML = (ie8InnerHTMLTestElement.outerHTML.indexOf('id=womp') > -1);
    function normalizeInnerHTML(actualHTML) {
      if (ie8InnerHTML) {
        // drop newlines in IE8
        actualHTML = actualHTML.replace(/\r\n/gm, '');
        // downcase ALLCAPS tags in IE8
        actualHTML = actualHTML.replace(/<\/?[A-Z]+/gi, function(tag){
          return tag.toLowerCase();
        });
        // quote ids in IE8
        actualHTML = actualHTML.replace(/id=([^ >]+)/gi, function(match, id){
          return 'id="'+id+'"';
        });
      }
      return actualHTML;
    }

    __exports__.normalizeInnerHTML = normalizeInnerHTML;// detect weird IE8 checked element string
    var checkedInput = document.createElement('input');
    checkedInput.setAttribute('checked', 'checked');
    var checkedInputString = checkedInput.outerHTML;
    function isCheckedInputHTML(element) {
      equal(element.outerHTML, checkedInputString);
    }

    __exports__.isCheckedInputHTML = isCheckedInputHTML;
  });
define("htmlbars-test-helpers.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('htmlbars-test-helpers.js should pass jshint', function() { 
      ok(true, 'htmlbars-test-helpers.js should pass jshint.'); 
    });
  });
define("morph",
  ["./morph/morph","./morph/dom-helper","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var Morph = __dependency1__["default"];
    var DOMHelper = __dependency2__["default"];

    __exports__.Morph = Morph;
    __exports__.DOMHelper = DOMHelper;
  });
define("morph.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - .');
    test('morph.js should pass jshint', function() { 
      ok(true, 'morph.js should pass jshint.'); 
    });
  });
define("morph/dom-helper",
  ["../morph/morph","./dom-helper/build-html-dom","./dom-helper/classes","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    /* global window:false */
    var Morph = __dependency1__["default"];
    var buildHTMLDOM = __dependency2__.buildHTMLDOM;
    var svgNamespace = __dependency2__.svgNamespace;
    var svgHTMLIntegrationPoints = __dependency2__.svgHTMLIntegrationPoints;
    var addClasses = __dependency3__.addClasses;
    var removeClasses = __dependency3__.removeClasses;

    var doc = typeof document === 'undefined' ? false : document;

    var deletesBlankTextNodes = doc && (function(document){
      var element = document.createElement('div');
      element.appendChild( document.createTextNode('') );
      var clonedElement = element.cloneNode(true);
      return clonedElement.childNodes.length === 0;
    })(doc);

    var ignoresCheckedAttribute = doc && (function(document){
      var element = document.createElement('input');
      element.setAttribute('checked', 'checked');
      var clonedElement = element.cloneNode(false);
      return !clonedElement.checked;
    })(doc);

    function isSVG(ns){
      return ns === svgNamespace;
    }

    // This is not the namespace of the element, but of
    // the elements inside that elements.
    function interiorNamespace(element){
      if (
        element &&
        element.namespaceURI === svgNamespace &&
        !svgHTMLIntegrationPoints[element.tagName]
      ) {
        return svgNamespace;
      } else {
        return null;
      }
    }

    // The HTML spec allows for "omitted start tags". These tags are optional
    // when their intended child is the first thing in the parent tag. For
    // example, this is a tbody start tag:
    //
    // <table>
    //   <tbody>
    //     <tr>
    //
    // The tbody may be omitted, and the browser will accept and render:
    //
    // <table>
    //   <tr>
    //
    // However, the omitted start tag will still be added to the DOM. Here
    // we test the string and context to see if the browser is about to
    // perform this cleanup.
    //
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#optional-tags
    // describes which tags are omittable. The spec for tbody and colgroup
    // explains this behavior:
    //
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#the-tbody-element
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#the-colgroup-element
    //

    var omittedStartTagChildTest = /<([\w:]+)/;
    function detectOmittedStartTag(string, contextualElement){
      // Omitted start tags are only inside table tags.
      if (contextualElement.tagName === 'TABLE') {
        var omittedStartTagChildMatch = omittedStartTagChildTest.exec(string);
        if (omittedStartTagChildMatch) {
          var omittedStartTagChild = omittedStartTagChildMatch[1];
          // It is already asserted that the contextual element is a table
          // and not the proper start tag. Just see if a tag was omitted.
          return omittedStartTagChild === 'tr' ||
                 omittedStartTagChild === 'col';
        }
      }
    }

    function buildSVGDOM(html, dom){
      var div = dom.document.createElement('div');
      div.innerHTML = '<svg>'+html+'</svg>';
      return div.firstChild.childNodes;
    }

    /*
     * A class wrapping DOM functions to address environment compatibility,
     * namespaces, contextual elements for morph un-escaped content
     * insertion.
     *
     * When entering a template, a DOMHelper should be passed:
     *
     *   template(context, { hooks: hooks, dom: new DOMHelper() });
     *
     * TODO: support foreignObject as a passed contextual element. It has
     * a namespace (svg) that does not match its internal namespace
     * (xhtml).
     *
     * @class DOMHelper
     * @constructor
     * @param {HTMLDocument} _document The document DOM methods are proxied to
     */
    function DOMHelper(_document){
      this.document = _document || window.document;
      this.namespace = null;
    }

    var prototype = DOMHelper.prototype;
    prototype.constructor = DOMHelper;

    prototype.getElementById = function(id) {
      return this.document.getElementById(id);
    };

    prototype.insertBefore = function(element, childElement, referenceChild) {
      return element.insertBefore(childElement, referenceChild);
    };

    prototype.appendChild = function(element, childElement) {
      return element.appendChild(childElement);
    };

    prototype.appendText = function(element, text) {
      return element.appendChild(this.document.createTextNode(text));
    };

    prototype.setAttribute = function(element, name, value) {
      element.setAttribute(name, value);
    };

    prototype.removeAttribute = function(element, name) {
      element.removeAttribute(name);
    };

    prototype.setProperty = function(element, name, value) {
      element[name] = value;
    };

    if (doc && doc.createElementNS) {
      // Only opt into namespace detection if a contextualElement
      // is passed.
      prototype.createElement = function(tagName, contextualElement) {
        var namespace = this.namespace;
        if (contextualElement) {
          if (tagName === 'svg') {
            namespace = svgNamespace;
          } else {
            namespace = interiorNamespace(contextualElement);
          }
        }
        if (namespace) {
          return this.document.createElementNS(namespace, tagName);
        } else {
          return this.document.createElement(tagName);
        }
      };
    } else {
      prototype.createElement = function(tagName) {
        return this.document.createElement(tagName);
      };
    }

    prototype.addClasses = addClasses;
    prototype.removeClasses = removeClasses;

    prototype.setNamespace = function(ns) {
      this.namespace = ns;
    };

    prototype.detectNamespace = function(element) {
      this.namespace = interiorNamespace(element);
    };

    prototype.createDocumentFragment = function(){
      return this.document.createDocumentFragment();
    };

    prototype.createTextNode = function(text){
      return this.document.createTextNode(text);
    };

    prototype.createComment = function(text){
      return this.document.createComment(text);
    };

    prototype.repairClonedNode = function(element, blankChildTextNodes, isChecked){
      if (deletesBlankTextNodes && blankChildTextNodes.length > 0) {
        for (var i=0, len=blankChildTextNodes.length;i<len;i++){
          var textNode = this.document.createTextNode(''),
              offset = blankChildTextNodes[i],
              before = element.childNodes[offset];
          if (before) {
            element.insertBefore(textNode, before);
          } else {
            element.appendChild(textNode);
          }
        }
      }
      if (ignoresCheckedAttribute && isChecked) {
        element.setAttribute('checked', 'checked');
      }
    };

    prototype.cloneNode = function(element, deep){
      var clone = element.cloneNode(!!deep);
      return clone;
    };

    prototype.createMorph = function(parent, start, end, contextualElement){
      if (!contextualElement && parent.nodeType === 1) {
        contextualElement = parent;
      }
      return new Morph(parent, start, end, this, contextualElement);
    };

    prototype.createUnsafeMorph = function(parent, start, end, contextualElement){
      var morph = this.createMorph(parent, start, end, contextualElement);
      morph.escaped = false;
      return morph;
    };

    // This helper is just to keep the templates good looking,
    // passing integers instead of element references.
    prototype.createMorphAt = function(parent, startIndex, endIndex, contextualElement){
      var childNodes = parent.childNodes,
          start = startIndex === -1 ? null : childNodes[startIndex],
          end = endIndex === -1 ? null : childNodes[endIndex];
      return this.createMorph(parent, start, end, contextualElement);
    };

    prototype.createUnsafeMorphAt = function(parent, startIndex, endIndex, contextualElement) {
      var morph = this.createMorphAt(parent, startIndex, endIndex, contextualElement);
      morph.escaped = false;
      return morph;
    };

    prototype.insertMorphBefore = function(element, referenceChild, contextualElement) {
      var start = this.document.createTextNode('');
      var end = this.document.createTextNode('');
      element.insertBefore(start, referenceChild);
      element.insertBefore(end, referenceChild);
      return this.createMorph(element, start, end, contextualElement);
    };

    prototype.appendMorph = function(element, contextualElement) {
      var start = this.document.createTextNode('');
      var end = this.document.createTextNode('');
      element.appendChild(start);
      element.appendChild(end);
      return this.createMorph(element, start, end, contextualElement);
    };

    prototype.parseHTML = function(html, contextualElement) {
      var isSVGContent = (
        isSVG(this.namespace) &&
        !svgHTMLIntegrationPoints[contextualElement.tagName]
      );

      if (isSVGContent) {
        return buildSVGDOM(html, this);
      } else {
        var nodes = buildHTMLDOM(html, contextualElement, this);
        if (detectOmittedStartTag(html, contextualElement)) {
          var node = nodes[0];
          while (node && node.nodeType !== 1) {
            node = node.nextSibling;
          }
          return node.childNodes;
        } else {
          return nodes;
        }
      }
    };

    __exports__["default"] = DOMHelper;
  });
define("morph/dom-helper.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - morph');
    test('morph/dom-helper.js should pass jshint', function() { 
      ok(true, 'morph/dom-helper.js should pass jshint.'); 
    });
  });
define("morph/dom-helper/build-html-dom",
  ["exports"],
  function(__exports__) {
    "use strict";
    /* global XMLSerializer:false */
    var svgHTMLIntegrationPoints = {foreignObject: 1, desc: 1, title: 1};
    __exports__.svgHTMLIntegrationPoints = svgHTMLIntegrationPoints;var svgNamespace = 'http://www.w3.org/2000/svg';
    __exports__.svgNamespace = svgNamespace;
    var doc = typeof document === 'undefined' ? false : document;

    // Safari does not like using innerHTML on SVG HTML integration
    // points (desc/title/foreignObject).
    var needsIntegrationPointFix = doc && (function(document) {
      if (document.createElementNS === undefined) {
        return;
      }
      // In FF title will not accept innerHTML.
      var testEl = document.createElementNS(svgNamespace, 'title');
      testEl.innerHTML = "<div></div>";
      return testEl.childNodes.length === 0 || testEl.childNodes[0].nodeType !== 1;
    })(doc);

    // Internet Explorer prior to 9 does not allow setting innerHTML if the first element
    // is a "zero-scope" element. This problem can be worked around by making
    // the first node an invisible text node. We, like Modernizr, use &shy;
    var needsShy = doc && (function(document) {
      var testEl = document.createElement('div');
      testEl.innerHTML = "<div></div>";
      testEl.firstChild.innerHTML = "<script><\/script>";
      return testEl.firstChild.innerHTML === '';
    })(doc);

    // IE 8 (and likely earlier) likes to move whitespace preceeding
    // a script tag to appear after it. This means that we can
    // accidentally remove whitespace when updating a morph.
    var movesWhitespace = doc && (function(document) {
      var testEl = document.createElement('div');
      testEl.innerHTML = "Test: <script type='text/x-placeholder'><\/script>Value";
      return testEl.childNodes[0].nodeValue === 'Test:' &&
              testEl.childNodes[2].nodeValue === ' Value';
    })(doc);

    // IE8 create a selected attribute where they should only
    // create a property
    var createsSelectedAttribute = doc && (function(document) {
      var testEl = document.createElement('div');
      testEl.innerHTML = "<select><option></option></select>";
      return testEl.childNodes[0].childNodes[0].getAttribute('selected') === 'selected';
    })(doc);

    var detectAutoSelectedOption;
    if (createsSelectedAttribute) {
      detectAutoSelectedOption = (function(){
        var detectAutoSelectedOptionRegex = /<option[^>]*selected/;
        return function detectAutoSelectedOption(select, option, html) { //jshint ignore:line
          return select.selectedIndex === 0 &&
                 !detectAutoSelectedOptionRegex.test(html);
        };
      })();
    } else {
      detectAutoSelectedOption = function detectAutoSelectedOption(select, option, html) { //jshint ignore:line
        var selectedAttribute = option.getAttribute('selected');
        return select.selectedIndex === 0 && (
                 selectedAttribute === null ||
                 ( selectedAttribute !== '' && selectedAttribute.toLowerCase() !== 'selected' )
                );
      };
    }

    var tagNamesRequiringInnerHTMLFix = doc && (function(document) {
      var tagNamesRequiringInnerHTMLFix;
      // IE 9 and earlier don't allow us to set innerHTML on col, colgroup, frameset,
      // html, style, table, tbody, tfoot, thead, title, tr. Detect this and add
      // them to an initial list of corrected tags.
      //
      // Here we are only dealing with the ones which can have child nodes.
      //
      var tableNeedsInnerHTMLFix;
      var tableInnerHTMLTestElement = document.createElement('table');
      try {
        tableInnerHTMLTestElement.innerHTML = '<tbody></tbody>';
      } catch (e) {
      } finally {
        tableNeedsInnerHTMLFix = (tableInnerHTMLTestElement.childNodes.length === 0);
      }
      if (tableNeedsInnerHTMLFix) {
        tagNamesRequiringInnerHTMLFix = {
          colgroup: ['table'],
          table: [],
          tbody: ['table'],
          tfoot: ['table'],
          thead: ['table'],
          tr: ['table', 'tbody']
        };
      }

      // IE 8 doesn't allow setting innerHTML on a select tag. Detect this and
      // add it to the list of corrected tags.
      //
      var selectInnerHTMLTestElement = document.createElement('select');
      selectInnerHTMLTestElement.innerHTML = '<option></option>';
      if (!selectInnerHTMLTestElement.childNodes[0]) {
        tagNamesRequiringInnerHTMLFix = tagNamesRequiringInnerHTMLFix || {};
        tagNamesRequiringInnerHTMLFix.select = [];
      }
      return tagNamesRequiringInnerHTMLFix;
    })(doc);

    function scriptSafeInnerHTML(element, html) {
      // without a leading text node, IE will drop a leading script tag.
      html = '&shy;'+html;

      element.innerHTML = html;

      var nodes = element.childNodes;

      // Look for &shy; to remove it.
      var shyElement = nodes[0];
      while (shyElement.nodeType === 1 && !shyElement.nodeName) {
        shyElement = shyElement.firstChild;
      }
      // At this point it's the actual unicode character.
      if (shyElement.nodeType === 3 && shyElement.nodeValue.charAt(0) === "\u00AD") {
        var newValue = shyElement.nodeValue.slice(1);
        if (newValue.length) {
          shyElement.nodeValue = shyElement.nodeValue.slice(1);
        } else {
          shyElement.parentNode.removeChild(shyElement);
        }
      }

      return nodes;
    }

    function buildDOMWithFix(html, contextualElement){
      var tagName = contextualElement.tagName;

      // Firefox versions < 11 do not have support for element.outerHTML.
      var outerHTML = contextualElement.outerHTML || new XMLSerializer().serializeToString(contextualElement);
      if (!outerHTML) {
        throw "Can't set innerHTML on "+tagName+" in this browser";
      }

      var wrappingTags = tagNamesRequiringInnerHTMLFix[tagName.toLowerCase()];
      var startTag = outerHTML.match(new RegExp("<"+tagName+"([^>]*)>", 'i'))[0];
      var endTag = '</'+tagName+'>';

      var wrappedHTML = [startTag, html, endTag];

      var i = wrappingTags.length;
      var wrappedDepth = 1 + i;
      while(i--) {
        wrappedHTML.unshift('<'+wrappingTags[i]+'>');
        wrappedHTML.push('</'+wrappingTags[i]+'>');
      }

      var wrapper = document.createElement('div');
      scriptSafeInnerHTML(wrapper, wrappedHTML.join(''));
      var element = wrapper;
      while (wrappedDepth--) {
        element = element.firstChild;
        while (element && element.nodeType !== 1) {
          element = element.nextSibling;
        }
      }
      while (element && element.tagName !== tagName) {
        element = element.nextSibling;
      }
      return element ? element.childNodes : [];
    }

    var buildDOM;
    if (needsShy) {
      buildDOM = function buildDOM(html, contextualElement, dom){
        contextualElement = dom.cloneNode(contextualElement, false);
        scriptSafeInnerHTML(contextualElement, html);
        return contextualElement.childNodes;
      };
    } else {
      buildDOM = function buildDOM(html, contextualElement, dom){
        contextualElement = dom.cloneNode(contextualElement, false);
        contextualElement.innerHTML = html;
        return contextualElement.childNodes;
      };
    }

    var buildIESafeDOM;
    if (tagNamesRequiringInnerHTMLFix || movesWhitespace) {
      buildIESafeDOM = function buildIESafeDOM(html, contextualElement, dom) {
        // Make a list of the leading text on script nodes. Include
        // script tags without any whitespace for easier processing later.
        var spacesBefore = [];
        var spacesAfter = [];
        html = html.replace(/(\s*)(<script)/g, function(match, spaces, tag) {
          spacesBefore.push(spaces);
          return tag;
        });

        html = html.replace(/(<\/script>)(\s*)/g, function(match, tag, spaces) {
          spacesAfter.push(spaces);
          return tag;
        });

        // Fetch nodes
        var nodes;
        if (tagNamesRequiringInnerHTMLFix[contextualElement.tagName.toLowerCase()]) {
          // buildDOMWithFix uses string wrappers for problematic innerHTML.
          nodes = buildDOMWithFix(html, contextualElement);
        } else {
          nodes = buildDOM(html, contextualElement, dom);
        }

        // Build a list of script tags, the nodes themselves will be
        // mutated as we add test nodes.
        var i, j, node, nodeScriptNodes;
        var scriptNodes = [];
        for (i=0;i<nodes.length;i++) {
          node=nodes[i];
          if (node.nodeType !== 1) {
            continue;
          }
          if (node.tagName === 'SCRIPT') {
            scriptNodes.push(node);
          } else {
            nodeScriptNodes = node.getElementsByTagName('script');
            for (j=0;j<nodeScriptNodes.length;j++) {
              scriptNodes.push(nodeScriptNodes[j]);
            }
          }
        }

        // Walk the script tags and put back their leading text nodes.
        var scriptNode, textNode, spaceBefore, spaceAfter;
        for (i=0;i<scriptNodes.length;i++) {
          scriptNode = scriptNodes[i];
          spaceBefore = spacesBefore[i];
          if (spaceBefore && spaceBefore.length > 0) {
            textNode = dom.document.createTextNode(spaceBefore);
            scriptNode.parentNode.insertBefore(textNode, scriptNode);
          }

          spaceAfter = spacesAfter[i];
          if (spaceAfter && spaceAfter.length > 0) {
            textNode = dom.document.createTextNode(spaceAfter);
            scriptNode.parentNode.insertBefore(textNode, scriptNode.nextSibling);
          }
        }

        return nodes;
      };
    } else {
      buildIESafeDOM = buildDOM;
    }

    // When parsing innerHTML, the browser may set up DOM with some things
    // not desired. For example, with a select element context and option
    // innerHTML the first option will be marked selected.
    //
    // This method cleans up some of that, resetting those values back to
    // their defaults.
    //
    function buildSafeDOM(html, contextualElement, dom) {
      var childNodes = buildIESafeDOM(html, contextualElement, dom);

      if (contextualElement.tagName === 'SELECT') {
        // Walk child nodes
        for (var i = 0; childNodes[i]; i++) {
          // Find and process the first option child node
          if (childNodes[i].tagName === 'OPTION') {
            if (detectAutoSelectedOption(childNodes[i].parentNode, childNodes[i], html)) {
              // If the first node is selected but does not have an attribute,
              // presume it is not really selected.
              childNodes[i].parentNode.selectedIndex = -1;
            }
            break;
          }
        }
      }

      return childNodes;
    }

    var buildHTMLDOM;
    if (needsIntegrationPointFix) {
      buildHTMLDOM = function buildHTMLDOM(html, contextualElement, dom){
        if (svgHTMLIntegrationPoints[contextualElement.tagName]) {
          return buildSafeDOM(html, document.createElement('div'), dom);
        } else {
          return buildSafeDOM(html, contextualElement, dom);
        }
      };
    } else {
      buildHTMLDOM = buildSafeDOM;
    }

    __exports__.buildHTMLDOM = buildHTMLDOM;
  });
define("morph/dom-helper/build-html-dom.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - morph/dom-helper');
    test('morph/dom-helper/build-html-dom.js should pass jshint', function() { 
      ok(true, 'morph/dom-helper/build-html-dom.js should pass jshint.'); 
    });
  });
define("morph/dom-helper/classes",
  ["exports"],
  function(__exports__) {
    "use strict";
    var doc = typeof document === 'undefined' ? false : document;

    // PhantomJS has a broken classList. See https://github.com/ariya/phantomjs/issues/12782
    var canClassList = doc && (function(){
      var d = document.createElement('div');
      if (!d.classList) {
        return false;
      }
      d.classList.add('boo');
      d.classList.add('boo', 'baz');
      return (d.className === 'boo baz');
    })();

    function buildClassList(element) {
      var classString = (element.getAttribute('class') || '');
      return classString !== '' && classString !== ' ' ? classString.split(' ') : [];
    }

    function intersect(containingArray, valuesArray) {
      var containingIndex = 0;
      var containingLength = containingArray.length;
      var valuesIndex = 0;
      var valuesLength = valuesArray.length;

      var intersection = new Array(valuesLength);

      // TODO: rewrite this loop in an optimal manner
      for (;containingIndex<containingLength;containingIndex++) {
        valuesIndex = 0;
        for (;valuesIndex<valuesLength;valuesIndex++) {
          if (valuesArray[valuesIndex] === containingArray[containingIndex]) {
            intersection[valuesIndex] = containingIndex;
            break;
          }
        }
      }

      return intersection;
    }

    function addClassesViaAttribute(element, classNames) {
      var existingClasses = buildClassList(element);

      var indexes = intersect(existingClasses, classNames);
      var didChange = false;

      for (var i=0, l=classNames.length; i<l; i++) {
        if (indexes[i] === undefined) {
          didChange = true;
          existingClasses.push(classNames[i]);
        }
      }

      if (didChange) {
        element.setAttribute('class', existingClasses.length > 0 ? existingClasses.join(' ') : '');
      }
    }

    function removeClassesViaAttribute(element, classNames) {
      var existingClasses = buildClassList(element);

      var indexes = intersect(classNames, existingClasses);
      var didChange = false;
      var newClasses = [];

      for (var i=0, l=existingClasses.length; i<l; i++) {
        if (indexes[i] === undefined) {
          newClasses.push(existingClasses[i]);
        } else {
          didChange = true;
        }
      }

      if (didChange) {
        element.setAttribute('class', newClasses.length > 0 ? newClasses.join(' ') : '');
      }
    }

    var addClasses, removeClasses;
    if (canClassList) {
      addClasses = function addClasses(element, classNames) {
        if (element.classList) {
          if (classNames.length === 1) {
            element.classList.add(classNames[0]);
          } else if (classNames.length === 2) {
            element.classList.add(classNames[0], classNames[1]);
          } else {
            element.classList.add.apply(element.classList, classNames);
          }
        } else {
          addClassesViaAttribute(element, classNames);
        }
      };
      removeClasses = function removeClasses(element, classNames) {
        if (element.classList) {
          if (classNames.length === 1) {
            element.classList.remove(classNames[0]);
          } else if (classNames.length === 2) {
            element.classList.remove(classNames[0], classNames[1]);
          } else {
            element.classList.remove.apply(element.classList, classNames);
          }
        } else {
          removeClassesViaAttribute(element, classNames);
        }
      };
    } else {
      addClasses = addClassesViaAttribute;
      removeClasses = removeClassesViaAttribute;
    }

    __exports__.addClasses = addClasses;
    __exports__.removeClasses = removeClasses;
  });
define("morph/dom-helper/classes.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - morph/dom-helper');
    test('morph/dom-helper/classes.js should pass jshint', function() { 
      ok(true, 'morph/dom-helper/classes.js should pass jshint.'); 
    });
  });
define("morph/morph",
  ["exports"],
  function(__exports__) {
    "use strict";
    var splice = Array.prototype.splice;

    function ensureStartEnd(start, end) {
      if (start === null || end === null) {
        throw new Error('a fragment parent must have boundary nodes in order to detect insertion');
      }
    }

    function ensureContext(contextualElement) {
      if (!contextualElement || contextualElement.nodeType !== 1) {
        throw new Error('An element node must be provided for a contextualElement, you provided ' +
                        (contextualElement ? 'nodeType ' + contextualElement.nodeType : 'nothing'));
      }
    }

    // TODO: this is an internal API, this should be an assert
    function Morph(parent, start, end, domHelper, contextualElement) {
      if (parent.nodeType === 11) {
        ensureStartEnd(start, end);
        this.element = null;
      } else {
        this.element = parent;
      }
      this._parent = parent;
      this.start = start;
      this.end = end;
      this.domHelper = domHelper;
      ensureContext(contextualElement);
      this.contextualElement = contextualElement;
      this.escaped = true;
      this.reset();
    }

    Morph.prototype.reset = function() {
      this.text = null;
      this.owner = null;
      this.morphs = null;
      this.before = null;
      this.after = null;
    };

    Morph.prototype.parent = function () {
      if (!this.element) {
        var parent = this.start.parentNode;
        if (this._parent !== parent) {
          this._parent = parent;
        }
        if (parent.nodeType === 1) {
          this.element = parent;
        }
      }
      return this._parent;
    };

    Morph.prototype.destroy = function () {
      if (this.owner) {
        this.owner.removeMorph(this);
      } else {
        clear(this.element || this.parent(), this.start, this.end);
      }
    };

    Morph.prototype.removeMorph = function (morph) {
      var morphs = this.morphs;
      for (var i=0, l=morphs.length; i<l; i++) {
        if (morphs[i] === morph) {
          this.replace(i, 1);
          break;
        }
      }
    };

    Morph.prototype.update = function (nodeOrString) {
      this._update(this.element || this.parent(), nodeOrString);
    };

    Morph.prototype.updateNode = function (node) {
      var parent = this.element || this.parent();
      if (!node) {
        return this._updateText(parent, '');
      }
      this._updateNode(parent, node);
    };

    Morph.prototype.updateText = function (text) {
      this._updateText(this.element || this.parent(), text);
    };

    Morph.prototype.updateHTML = function (html) {
      var parent = this.element || this.parent();
      if (!html) {
        return this._updateText(parent, '');
      }
      this._updateHTML(parent, html);
    };

    Morph.prototype._update = function (parent, nodeOrString) {
      if (nodeOrString === null || nodeOrString === undefined) {
        this._updateText(parent, '');
      } else if (typeof nodeOrString === 'string') {
        if (this.escaped) {
          this._updateText(parent, nodeOrString);
        } else {
          this._updateHTML(parent, nodeOrString);
        }
      } else if (nodeOrString.nodeType) {
        this._updateNode(parent, nodeOrString);
      } else if (nodeOrString.string) { // duck typed SafeString
        this._updateHTML(parent, nodeOrString.string);
      } else {
        this._updateText(parent, nodeOrString.toString());
      }
    };

    Morph.prototype._updateNode = function (parent, node) {
      if (this.text) {
        if (node.nodeType === 3) {
          this.text.nodeValue = node.nodeValue;
          return;
        } else {
          this.text = null;
        }
      }
      var start = this.start, end = this.end;
      clear(parent, start, end);
      parent.insertBefore(node, end);
      if (this.before !== null) {
        this.before.end = start.nextSibling;
      }
      if (this.after !== null) {
        this.after.start = end.previousSibling;
      }
    };

    Morph.prototype._updateText = function (parent, text) {
      if (this.text) {
        this.text.nodeValue = text;
        return;
      }
      var node = this.domHelper.createTextNode(text);
      this.text = node;
      clear(parent, this.start, this.end);
      parent.insertBefore(node, this.end);
      if (this.before !== null) {
        this.before.end = node;
      }
      if (this.after !== null) {
        this.after.start = node;
      }
    };

    Morph.prototype._updateHTML = function (parent, html) {
      var start = this.start, end = this.end;
      clear(parent, start, end);
      this.text = null;
      var childNodes = this.domHelper.parseHTML(html, this.contextualElement);
      appendChildren(parent, end, childNodes);
      if (this.before !== null) {
        this.before.end = start.nextSibling;
      }
      if (this.after !== null) {
        this.after.start = end.previousSibling;
      }
    };

    Morph.prototype.append = function (node) {
      if (this.morphs === null) {
        this.morphs = [];
      }
      var index = this.morphs.length;
      return this.insert(index, node);
    };

    Morph.prototype.insert = function (index, node) {
      if (this.morphs === null) {
        this.morphs = [];
      }
      var parent = this.element || this.parent();
      var morphs = this.morphs;
      var before = index > 0 ? morphs[index-1] : null;
      var after  = index < morphs.length ? morphs[index] : null;
      var start  = before === null ? this.start : (before.end === null ? parent.lastChild : before.end.previousSibling);
      var end    = after === null ? this.end : (after.start === null ? parent.firstChild : after.start.nextSibling);
      var morph  = new Morph(parent, start, end, this.domHelper, this.contextualElement);

      morph.owner = this;
      morph._update(parent, node);

      if (before !== null) {
        morph.before = before;
        before.end = start.nextSibling;
        before.after = morph;
      }

      if (after !== null) {
        morph.after = after;
        after.before = morph;
        after.start = end.previousSibling;
      }

      this.morphs.splice(index, 0, morph);
      return morph;
    };

    Morph.prototype.replace = function (index, removedLength, addedNodes) {
      if (this.morphs === null) {
        this.morphs = [];
      }
      var parent = this.element || this.parent();
      var morphs = this.morphs;
      var before = index > 0 ? morphs[index-1] : null;
      var after = index+removedLength < morphs.length ? morphs[index+removedLength] : null;
      var start = before === null ? this.start : (before.end === null ? parent.lastChild : before.end.previousSibling);
      var end   = after === null ? this.end : (after.start === null ? parent.firstChild : after.start.nextSibling);
      var addedLength = addedNodes === undefined ? 0 : addedNodes.length;
      var args, i, current;

      if (removedLength > 0) {
        clear(parent, start, end);
      }

      if (addedLength === 0) {
        if (before !== null) {
          before.after = after;
          before.end = end;
        }
        if (after !== null) {
          after.before = before;
          after.start = start;
        }
        morphs.splice(index, removedLength);
        return;
      }

      args = new Array(addedLength+2);
      if (addedLength > 0) {
        for (i=0; i<addedLength; i++) {
          args[i+2] = current = new Morph(parent, start, end, this.domHelper, this.contextualElement);
          current._update(parent, addedNodes[i]);
          current.owner = this;
          if (before !== null) {
            current.before = before;
            before.end = start.nextSibling;
            before.after = current;
          }
          before = current;
          start = end === null ? parent.lastChild : end.previousSibling;
        }
        if (after !== null) {
          current.after = after;
          after.before = current;
          after.start = end.previousSibling;
        }
      }

      args[0] = index;
      args[1] = removedLength;

      splice.apply(morphs, args);
    };

    function appendChildren(parent, end, nodeList) {
      var ref = end;
      var i = nodeList.length;
      var node;

      while (i--) {
        node = nodeList[i];
        parent.insertBefore(node, ref);
        ref = node;
      }
    }

    function clear(parent, start, end) {
      var current, previous;
      if (end === null) {
        current = parent.lastChild;
      } else {
        current = end.previousSibling;
      }

      while (current !== null && current !== start) {
        previous = current.previousSibling;
        parent.removeChild(current);
        current = previous;
      }
    }

    __exports__["default"] = Morph;
  });
define("morph/morph.jshint",
  [],
  function() {
    "use strict";
    module('JSHint - morph');
    test('morph/morph.js should pass jshint', function() { 
      ok(true, 'morph/morph.js should pass jshint.'); 
    });
  });